# -*- coding: utf-8 -*-
"""дз_5_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R6nyEoeyKGUopYu1_WDiMDHzgR96omZW
"""

#1
import cmath

class ComplexNumberError(Exception):
  #исключение для ошибок, специфичных для комплексных чисел
  pass

class Complex:
  def __init__(self, real=0, imag=0):
    self._real = real
    self._imag = imag

  @property
  def real(self):
    #Getter для действительной части
    return self._real

  @real.setter
  def real(self, value):
    #Setter для действительной части
    if not isinstance(value, (int, float)):
      raise ValueError("действительная часть должна быть числом")
    self._real = value

  @property
  def imag(self):
    #Getter для мнимой части
    return self._imag

  @imag.setter
  def imag(self, value):
    #Setter для мнимой части
    if not isinstance(value, (int, float)):
      raise ValueError("мнимая часть должна быть числом.")
    self._imag = value

  def __str__(self):
    #Строковое представление комплексного числа
    if self._imag >= 0:
      return f"{self._real} + {self._imag}i"
    else:
      return f"{self._real} - {-self._imag}i"

  def __repr__(self):
    #Строковое представление для разработчика
    return f"Complex({self._real}, {self._imag})"

  def __abs__(self):
    #Модуль комплексного числа
    return (self._real**2 + self._imag**2)**0.5

  def __add__(self, other):
    if isinstance(other, Complex):
      return Complex(self._real + other.real, self._imag + other.imag)
    elif isinstance(other, (int, float)):
      return Complex(self._real + other, self._imag)
    else:
      return NotImplemented

  def __radd__(self, other):
    #сложение с обратным порядком
    return self.__add__(other)

  def __sub__(self, other):
    if isinstance(other, Complex):
      return Complex(self._real - other.real, self._imag - other.imag)
    elif isinstance(other, (int, float)):
      return Complex(self._real - other, self._imag)
    else:
      return NotImplemented

  def __rsub__(self, other):
    #Вычитание с обратным порядком
    return Complex(other - self._real, -self._imag)

  def __mul__(self, other):
    if isinstance(other, Complex):
      return Complex(self._real * other.real - self._imag * other.imag,
             self._real * other.imag + self._imag * other.real)
    elif isinstance(other, (int, float)):
      return Complex(self._real * other, self._imag * other)
    else:
      return NotImplemented

  def __rmul__(self, other):
    #Умножение с обратным порядком
    return self.__mul__(other)

  def __truediv__(self, other):
    if isinstance(other, Complex):
      denominator = other.real**2 + other.imag**2
      if denominator == 0:
        raise ZeroDivisionError("деление на ноль")
      return Complex((self._real * other.real + self._imag * other.imag) / denominator,
             (self._imag * other.real - self._real * other.imag) / denominator)
    elif isinstance(other, (int, float)):
      if other == 0:
        raise ZeroDivisionError("деление на ноль")
      return Complex(self._real / other, self._imag / other)
    else:
      return NotImplemented

  def __rtruediv__(self, other):
    #Деление с обратным порядком
    if isinstance(other, (int, float)):
      return self.__truediv__(Complex(other, 0))
    else:
      return NotImplemented

  def __eq__(self, other):
    if isinstance(other, Complex):
      return self._real == other.real and self._imag == other.imag
    elif isinstance(other, (int, float)):
      return self._real == other and self._imag == 0
    else:
      return False

  def expon(self):
    #Перевод в экспоненциальную форму
    if self._real == 0 and self._imag == 0:
      raise ComplexNumberError("невозможно перевести нулевое комплексное число в экспоненциальную форму.")
    module = abs(self)
    argument = cmath.phase(complex(self._real, self._imag))
    return f"{module} * exp({argument}i)"

def main():
  #Функция для запуск калькулятора
  while True:
    try:
      real1 = float(input("Введите действительную часть первого комплексного числа: "))
      imag1 = float(input("Введите мнимую часть первого комплексного числа: "))
      real2 = float(input("Введите действительную часть второго комплексного числа: "))
      imag2 = float(input("Введите мнимую часть второго комплексного числа: "))

      comp1 = Complex(real1, imag1)
      comp2 = Complex(real2, imag2)

      print('Выберите операцию:')
      print("1. Сложение")
      print("2. Вычитание")
      print("3. Умножение")
      print("4. Деление")
      print("5. Выход")

      choice = input('Введите номер операции: ')

      if choice == '1':
        result = comp1 + comp2
        print(f"Результат: {result}")
      elif choice == '2':
        result = comp1 - comp2
        print(f"Результат: {result}")
      elif choice == '3':
        result = comp1 * comp2
        print(f"Результат: {result}")
      elif choice == '4':
        result = comp1 / comp2
        print(f"Результат: {result}")
      elif choice == '5':
        break
      else:
        print('Неверный ввод')
    except ValueError:
      print('Ошибка ввода: Пожалуйста, введите числовые значения')
    except ComplexNumberError as e:
      print(f"Ошибка комплексного числа: {e}")
    except ZeroDivisionError:
      print('Ошибка: Деление на ноль')


if __name__ == "__main__":
  main()

#2
class Node:
    #вспомогательный класс. каждый узел хранит данные (data) и ссылку на следующий узел (next)
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    #реализуем класс связного списка
    def __init__(self):
        self.head = None
        self.length = 0

    def __len__(self):
        #длина списка
        return self.length

    def __str__(self):
        #преобразуем список в читаемое строковое представление
        current = self.head
        result = "["
        while current:
            result += str(current.data)
            if current.next:
                result += ", "
            current = current.next
        result += "]"
        return result

    def __getitem__(self, index):
        #элемент списка по индексу
        if not 0 <= index < self.length:
            raise IndexError("Индекс вне диапазона")
        current = self.head
        for _ in range(index):
            current = current.next
        return current.data

    def append(self, data):
        #добавить элемент
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        self.length += 1

    def pop(self):
        #удаляет и возвращает последний эл-т списка
        if self.head is None:
            raise IndexError("Список пуст")
        if self.length == 1:
            data = self.head.data
            self.head = None
        else:
            current = self.head
            while current.next.next:
                current = current.next
            data = current.next.data
            current.next = None
        self.length -= 1
        return data

    def insert(self, index, data):
        #вставить эле-т по индексу
        if not 0 <= index <= self.length:
            raise IndexError("Индекс вне диапазона")
        if index == 0:
            self.insert_at_beginning(data)
        else:
            new_node = Node(data)
            current = self.head
            for _ in range(index - 1):
                current = current.next
            new_node.next = current.next
            current.next = new_node
            self.length += 1

    def insert_at_beginning(self, data):
        #вставить в начало списка
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self.length += 1

    def pop_at_index(self, index):
        #удаляет и возвращает элемент по индексу
        if not 0 <= index < self.length:
            raise IndexError("Индекс вне диапазона")
        if index == 0:
            return self.pop_at_beginning()
        else:
            current = self.head
            for _ in range(index - 1):
                current = current.next
            data = current.next.data
            current.next = current.next.next
            self.length -= 1
            return data

    def pop_at_beginning(self):
        #удаляет и возвращает первый узел
        if self.head is None:
            raise IndexError("Список пуст")
        data = self.head.data
        self.head = self.head.next
        self.length -= 1
        return data

    def __iter__(self):
      # возвращает итератор по списку
      current = self.head
      while current:
        yield current.data
        current = current.next

my_list = LinkedList()
my_list.append(1)
my_list.append(2)
my_list.append(3)

print(my_list)
print(len(my_list))

print(my_list[1])

my_list.insert(1, 4)
print(my_list)

print(my_list.pop())
print(my_list)

for item in my_list:
  print(item)

#3
import math

class Shape:
  #класс геометрических фигур
  def area(self):
    #площадь
    raise NotImplementedError("Метод area() должен быть реализован в подклассах.")

  def perimeter(self):
    #периметр
    raise NotImplementedError("Метод perimeter() должен быть реализован в подклассах.")

  def __str__(self):
    #строковое представление
    raise NotImplementedError("Метод __str__() должен быть реализован в подклассах.")

class Circle(Shape):

  def __init__(self, radius):
    self.radius = radius

  def area(self):
    return math.pi * self.radius**2

  def perimeter(self):
    return 2 * math.pi * self.radius

  def __str__(self):
    return f"Круг с радиусом {self.radius}"

class Triangle(Shape):

  def __init__(self, point1, point2, point3):
    self.point1 = point1
    self.point2 = point2
    self.point3 = point3

  def area(self):
    a = self._calculate_side_length(self.point1, self.point2)
    b = self._calculate_side_length(self.point2, self.point3)
    c = self._calculate_side_length(self.point3, self.point1)
    s = (a + b + c) / 2
    return math.sqrt(s * (s - a) * (s - b) * (s - c))

  def perimeter(self):
    a = self._calculate_side_length(self.point1, self.point2)
    b = self._calculate_side_length(self.point2, self.point3)
    c = self._calculate_side_length(self.point3, self.point1)
    return a + b + c

  def __str__(self):
    return f"Треугольник с вершинами {self.point1}, {self.point2}, {self.point3}"

  def _calculate_side_length(self, point1, point2):
    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)

class Rectangle(Shape):

  def __init__(self, point1, point2):
    self.point1 = point1
    self.point2 = point2

  def area(self):
    width = abs(self.point1[0] - self.point2[0])
    height = abs(self.point1[1] - self.point2[1])
    return width * height

  def perimeter(self):
    width = abs(self.point1[0] - self.point2[0])
    height = abs(self.point1[1] - self.point2[1])
    return 2 * (width + height)

  def __str__(self):
    return f"Прямоугольник с вершинами {self.point1}, {self.point2}"

class Square(Rectangle):

  def __init__(self, point1, point2):
    super().__init__(point1, point2)
    if abs(self.point1[0] - self.point2[0]) != abs(self.point1[1] - self.point2[1]):
      raise ValueError("Стороны квадрата должны быть равны.")

  def __str__(self):
    return f"Квадрат с вершинами {self.point1}, {self.point2}"

class Rhombus(Shape):

  def __init__(self, point1, point2, point3, point4):
    self.point1 = point1
    self.point2 = point2
    self.point3 = point3
    self.point4 = point4

  def area(self):
    # Используем формулу площади ромба через диагонали
    diagonal1 = self._calculate_side_length(self.point1, self.point3)
    diagonal2 = self._calculate_side_length(self.point2, self.point4)
    return (diagonal1 * diagonal2) / 2

  def perimeter(self):
    side_length = self._calculate_side_length(self.point1, self.point2)
    return 4 * side_length

  def __str__(self):
    return f"Ромб с вершинами {self.point1}, {self.point2}, {self.point3}, {self.point4}"

  def _calculate_side_length(self, point1, point2):
    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)

circle = Circle(5)
print(circle)
print(f"Площадь круга: {circle.area()}")
print(f"Периметр круга: {circle.perimeter()}")

triangle = Triangle((0, 0), (3, 0), (1.5, 2.598))
print(triangle)
print(f"Площадь треугольника: {triangle.area()}")
print(f"Периметр треугольника: {triangle.perimeter()}")

rectangle = Rectangle((0, 0), (4, 3))
print(rectangle)
print(f"Площадь прямоугольника: {rectangle.area()}")
print(f"Периметр прямоугольника: {rectangle.perimeter()}")

square = Square((0, 0), (4, 4))
print(square)
print(f"Площадь квадрата: {square.area()}")
print(f"Периметр квадрата: {square.perimeter()}")

rhombus = Rhombus((0, 0), (2, 0), (1, 2), (-1, 0))
print(rhombus)
print(f"Площадь ромба: {rhombus.area()}")
print(f"Периметр ромба: {rhombus.perimeter()}")